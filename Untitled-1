public static void doOptimisticAlgorithm (HashMap<Integer, OptimisticTask> optimisticTaskMap, HashMap<Integer, Integer> resourceMap1) {
        int cycle = 0;
        List<OptimisticTask> terminatedTasks = new ArrayList<OptimisticTask>(); // List for terminated tasks   
        List<OptimisticTask> blockedTasks = new ArrayList<OptimisticTask>(); // List for the blocked tasks
        List<Map.Entry> addToResourceList = new ArrayList<Map.Entry>(); // List to add released resources AFTER cycle

        while (terminatedTasks.size() != optimisticTaskMap.size()) {
            System.out.println("CYCLE " + cycle + "--------------------------------uwu");
            Iterator it = optimisticTaskMap.entrySet().iterator();
            ArrayList<Integer> visitedTasks = new ArrayList<Integer>(); // To verify which are visited
            if (!blockedTasks.isEmpty()) { // First check blocked tasks
                for (OptimisticTask t : blockedTasks) {
                    if (t.getComputeTime()!=0) {
                        printAvailableResources(resourceMap1);
                        visitedTasks.add(t.getTaskNumber());
                        t.doNextActivity(resourceMap1, terminatedTasks, blockedTasks, addToResourceList, cycle);
                    }
                }
            }
            while (it.hasNext()) { // Do next activity for each Task
                printAvailableResources(resourceMap1);
                Map.Entry me = (Map.Entry) it.next();
                OptimisticTask t = (OptimisticTask)me.getValue();
                if (t.getComputeTime() != 0) {
                    t.decreaseComputeTime(); // If default compute time is 0, do nothing. Else, decrement compute time
                }
                else {
                    if (!visitedTasks.contains(t.getTaskNumber())) { // If blocked task was already checked, skip and only do tasks not checked.
                        t.doNextActivity(resourceMap1, terminatedTasks, blockedTasks, addToResourceList, cycle);
                    } 
                }
               
            }
            // If at the end of a cycle all tasks are blocked, then there is a deadlock. Release the resources of the first task and make them available at the start of the next cycle.
            while (isDeadLock(optimisticTaskMap, resourceMap1)) {
                // Get lowest task number
                Collections.sort(blockedTasks, new Comparator<OptimisticTask>() { // sort by taskNum
                    @Override
                    public int compare(OptimisticTask t1, OptimisticTask t2) {
                        return t1.getTaskNumber() - t2.getTaskNumber();
                    }
                });
                
                OptimisticTask lowestTask = blockedTasks.remove(0);
                // Remove lowest task's currently allocated resources and abort
                for (Map.Entry mEntry : lowestTask.getAllocatedResources().entrySet()) {
                    int resourceNum = (Integer)mEntry.getKey();
                    int units = (Integer)mEntry.getValue();
                    // don't need to update allocated resources, just need to update available resources
                    addToResourceList.add(mEntry);
                }
                // Map.Entry<Integer, Integer> me = new AbstractMap.SimpleEntry<Integer,Integer>(resourceNum, units);
                // addToResourceList.add(me);
                lowestTask.setAborted();
                terminatedTasks.add(lowestTask);
                System.out.println("Task " + lowestTask.getTaskNumber()+ " ABORTED");
            }
            while (!addToResourceList.isEmpty()) { // Update the available resources after a cycle, so those resources released during a cycle aren't available during the same cycle.
                for (Map.Entry mEntry : addToResourceList) {
                    Integer CurrentKey = (Integer)mEntry.getKey();
                    Integer CurrentValue = (Integer)mEntry.getValue();
                    resourceMap1.put(CurrentKey, CurrentValue+resourceMap1.get(CurrentKey));
                }
                addToResourceList.clear();

            }
            cycle++;
        }
        // for (Map.Entry mEntry : optimisticTaskMap.entrySet()) { // 
        //     OptimisticTask ot = (OptimisticTask)mEntry.getValue();
        //     ot.printActivities();
        // }

        printTasksOptimistic(terminatedTasks);
        

    }

    public static void printTasksOptimistic(List<OptimisticTask> terminatedTasks) {
        Collections.sort(terminatedTasks, new Comparator<OptimisticTask>() { // sort by taskNum
			@Override
			public int compare(OptimisticTask t1, OptimisticTask t2) {
				return t1.getTaskNumber() - t2.getTaskNumber();
			}
        });
        int totalRunningTime = 0;
        int totalWaitTime = 0;
        for (OptimisticTask t : terminatedTasks) {
            if (t.getAborted()) {
                t.printOutput(true);
            }
            else {
                t.printOutput(false);
                totalRunningTime += t.getFinishingTime();
                totalWaitTime += t.getWaitingTime();
            }
            
        }
        double totalPercentOfWaitingTime = (double)(totalWaitTime)/(totalRunningTime)* 100;
        System.out.printf("%-15s%-5d%-5d%d%%\n", "Total", totalRunningTime, totalWaitTime, (int)totalPercentOfWaitingTime);
    }

    public static boolean isDeadLock(HashMap<Integer, OptimisticTask> optimisticTaskMap, HashMap<Integer, Integer> resourceMap1) {
        for (Map.Entry mEntry : optimisticTaskMap.entrySet()) {
            OptimisticTask curTask = (OptimisticTask) mEntry.getValue();
            if (!curTask.checkDeadLock(resourceMap1)) { // if not deadlocked
                return false;
            }
        }
        return true;
    }


   